2. Visualvm с плагином Visual GC
   1) Мониторинг заполнения памяти по секторам молодого поколения, старого и
   метаданных, обьем выделенной памяти под каждый сектор, количество 
   отработанного сборщиком времени, количество сборок
   (также время затраченное компилятором и загрузчиком классов).
   В виде таблицы такую информацию можно получить с помощью утилиты jstat.
   Либо с помощью логгера самой jvm  -Xlog:gc* в виде подробного отсчета
   о миграции данных из одного сектора в другой при каждой сборке и 
   затраченном времени.

   2) На вкладке Sampler можно получить сводную таблицу по живым объектам и 
   занимаемый ими объем памяти. Этуже информацию нам может выдать утилита
   jmap.

   3) На вкладке Monitor есть те же самые графики что и в jconsole c нагрузкой
   на CPU, объемом занимаемой памяти, количеством задействованных потоков.

    На вкладке Overview можно посмотреть системные настройки и аргументы с
   которыми была запущена jvm.

3. Перед тем как память заканчивается gc судорожно начинает искать 
   кандидатов на удаление. При превышении максимально доступной памяти
   приложение падает с ошибкой:
   Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
   
Print Screens ко второму вопросу c данными по трекеру.
http://prnt.sc/15z98bq
http://prnt.sc/15z9beq
http://prnt.sc/15z9e94